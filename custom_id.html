<!DOCTYPE html>
<meta charset=utf-8>
<meta name=viewport content="initial-scale=1">
<link rel=stylesheet href=style.css>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/base16/gruvbox-dark-hard.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<title>Why using custom IDs for indexing is a bad idea: A deep dive into Elasticsearch&#39;s source code</title>

<h1 id="why-using-custom-ids-for-indexing-is-a-bad-idea-a-deep-dive-into-elasticsearchs-source-code">Why using custom IDs for indexing is a bad idea: A deep dive into Elasticsearch&#39;s source code</h1>
<p>Elasticsearch’s allows us to provide a ID during the indexing stage, this explicit _id although useful in client side can lead to slow indexing. Instead of using the _id field, you should set a alternative field in your doc & use that as a id for your
doc using term lookups.</p>
<pre><code class="language-java">PUT &lt;target&gt;/&lt;type&gt;/&lt;id&gt;</code></pre>
<p>Let go through a typical bulk indexing code flow and try to understand why adding custom id will lead to slow indexing.</p>
<p>On client side in java , we can create a indexing request like this  <code>new IndexRequest(indexName, myType, myCustomID)</code>  and then pass it to <code>BulkProcessor.add()</code>.</p>
<p>once the indexing request is executed, it eventually lands in <code>org.elasticsearch.action.bulk.TransportShardBulkAction</code>  on ES side, where it’s passed to <code>executeBulkItemRequest</code> and then to <code>executeIndexRequestOnPrimary</code> </p>
<pre><code class="language-java">/** Executes index operation on primary shard after updates mapping if dynamic mappings are found */
public static Engine.IndexResult executeIndexRequestOnPrimary(IndexRequest request, IndexShard primary,
                                                              MappingUpdatedAction mappingUpdatedAction) throws Exception {
    Engine.Index operation;
    try {
        operation = prepareIndexOperationOnPrimary(request, primary);
    } catch (MapperParsingException | IllegalArgumentException e) {
        return new Engine.IndexResult(e, request.version());
    }
    Mapping update = operation.parsedDoc().dynamicMappingsUpdate();
    final ShardId shardId = primary.shardId();
    if (update != null) {
        // can throw timeout exception when updating mappings or ISE for attempting to update default mappings
        // which are bubbled up
        try {
            mappingUpdatedAction.updateMappingOnMaster(shardId.getIndex(), request.type(), update);
        } catch (IllegalArgumentException e) {
            // throws IAE on conflicts merging dynamic mappings
            return new Engine.IndexResult(e, request.version());
        }
        try {
            operation = prepareIndexOperationOnPrimary(request, primary);
        } catch (MapperParsingException | IllegalArgumentException e) {
            return new Engine.IndexResult(e, request.version());
        }
        update = operation.parsedDoc().dynamicMappingsUpdate();
        if (update != null) {
            throw new ReplicationOperation.RetryOnPrimaryException(shardId,
                    &quot;Dynamic mappings are not available on the node that holds the primary yet&quot;);
        }
    }
    return primary.index(operation);
}
</code></pre>
<p>This method basically just parses the requests and does some validation, updates mapping if required and then passes it on to shard to be indexed on line <code>primary.index(operation)</code> which eventually gets passed to <code>InternalEngine.index</code> shown below</p>
<pre><code class="language-java">@Override
public IndexResult index(Index index) throws IOException {
    assert Objects.equals(index.uid().field(), uidField) : index.uid().field();
    final boolean doThrottle = index.origin().isRecovery() == false;
    try (ReleasableLock releasableLock = readLock.acquire()) {
        ensureOpen();
        assert assertVersionType(index);
        try (Releasable ignored = acquireLock(index.uid());
             Releasable indexThrottle = doThrottle ? () -&gt; {} : throttle.acquireThrottle()) {
            lastWriteNanos = index.startTime();
            /* A NOTE ABOUT APPEND ONLY OPTIMIZATIONS:
             * if we have an autoGeneratedID that comes into the engine we can potentially optimize
             * and just use addDocument instead of updateDocument and skip the entire version and index lookupVersion across the board.
             * Yet, we have to deal with multiple document delivery, for this we use a property of the document that is added
             * to detect if it has potentially been added before. We use the documents timestamp for this since it&#39;s something
             * that:
             *  - doesn&#39;t change per document
             *  - is preserved in the transaction log
             *  - and is assigned before we start to index / replicate
             * NOTE: it&#39;s not important for this timestamp to be consistent across nodes etc. it&#39;s just a number that is in the common
             * case increasing and can be used in the failure case when we retry and resent documents to establish a happens before relationship.
             * for instance:
             *  - doc A has autoGeneratedIdTimestamp = 10, isRetry = false
             *  - doc B has autoGeneratedIdTimestamp = 9, isRetry = false
             *
             *  while both docs are in in flight, we disconnect on one node, reconnect and send doc A again
             *  - now doc A&#39; has autoGeneratedIdTimestamp = 10, isRetry = true
             *
             *  if A&#39; arrives on the shard first we update maxUnsafeAutoIdTimestamp to 10 and use update document. All subsequent
             *  documents that arrive (A and B) will also use updateDocument since their timestamps are less than maxUnsafeAutoIdTimestamp.
             *  While this is not strictly needed for doc B it is just much simpler to implement since it will just de-optimize some doc in the worst case.
             *
             *  if A arrives on the shard first we use addDocument since maxUnsafeAutoIdTimestamp is &lt; 10. A` will then just be skipped or calls
             *  updateDocument.
             */
            final IndexingStrategy plan;

            if (index.origin() == Operation.Origin.PRIMARY) {
                plan = planIndexingAsPrimary(index);
            } else {
                // non-primary mode (i.e., replica or recovery)
                plan = planIndexingAsNonPrimary(index);
            }

            final IndexResult indexResult;
            if (plan.earlyResultOnPreFlightError.isPresent()) {
                indexResult = plan.earlyResultOnPreFlightError.get();
                assert indexResult.hasFailure();
            } else if (plan.indexIntoLucene) {
                indexResult = indexIntoLucene(index, plan);
            } else {
                assert index.origin() != Operation.Origin.PRIMARY;
                indexResult = new IndexResult(plan.versionForIndexing, plan.currentNotFoundOrDeleted);
            }
            if (indexResult.hasFailure() == false &amp;&amp;
                plan.indexIntoLucene &amp;&amp; // if we didn&#39;t store it in lucene, there is no need to store it in the translog
                index.origin() != Operation.Origin.LOCAL_TRANSLOG_RECOVERY) {
                Translog.Location location =
                    translog.add(new Translog.Index(index, indexResult));
                indexResult.setTranslogLocation(location);
            }
            indexResult.setTook(System.nanoTime() - index.startTime());
            indexResult.freeze();
            return indexResult;
        }
    } catch (RuntimeException | IOException e) {
        try {
            maybeFailEngine(&quot;index&quot;, e);
        } catch (Exception inner) {
            e.addSuppressed(inner);
        }
        throw e;
    }
}
</code></pre>
<p>Before indexing a plan is decided  , it  happens in <code>plan = planIndexingAsPrimary(index);</code>  Let’s see the definition of  <code>planIndexingAsPrimary</code> method</p>
<pre><code class="language-java">private IndexingStrategy planIndexingAsPrimary(Index index) throws IOException {
    assert index.origin() == Operation.Origin.PRIMARY:
        &quot;planing as primary but origin isn&#39;t. got &quot; + index.origin();
    final IndexingStrategy plan;
    // resolve an external operation into an internal one which is safe to replay
    if (canOptimizeAddDocument(index)) {
        if (mayHaveBeenIndexedBefore(index)) {
            plan = IndexingStrategy.overrideExistingAsIfNotThere(1L);
        } else {
            plan = IndexingStrategy.optimizedAppendOnly();
        }
    } else {
        ...
    }
    return plan;
}
</code></pre>
<p>In the <code>planIndexingAsPrimary</code> the <code>if(canOptimizeAddDocument(index))</code>  block   checks if document’s  autogenerated time stamp is set or not</p>
<pre><code class="language-java">private boolean canOptimizeAddDocument(Index index) {
    if (index.getAutoGeneratedIdTimestamp() != IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP) {
        assert index.getAutoGeneratedIdTimestamp() &gt;= 0 : &quot;autoGeneratedIdTimestamp must be positive but was: &quot;
            + index.getAutoGeneratedIdTimestamp();
        switch (index.origin()) {
            casePRIMARY:
                assert (index.version() == Versions.MATCH_ANY&amp;&amp; index.versionType() == VersionType.INTERNAL)
                    : &quot;version: &quot; + index.version() + &quot; type: &quot; + index.versionType();
                return true;
            casePEER_RECOVERY:
            caseREPLICA:
                assert index.version() == 1 &amp;&amp; index.versionType() == VersionType.EXTERNAL : &quot;version: &quot; + index.version() + &quot; type: &quot; + index.versionType();
                return true;
            caseLOCAL_TRANSLOG_RECOVERY:
                assert index.isRetry();
                return true; // allow to optimize in order to update the max safe time stamp
            default:
                throw new IllegalArgumentException(&quot;unknown origin &quot; + index.origin());
        }
    }
    return false;
}
</code></pre>
<p>where  the value of <code>IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP</code> is defined as below</p>
<pre><code class="language-java">/**
 * Value for {@link#getAutoGeneratedTimestamp()} if the document has an external
 * provided ID.
 */
public static final intUNSET_AUTO_GENERATED_TIMESTAMP= -1;
</code></pre>
<p>in the <code>IndexRequest</code> class we  can see that , if id is null then only <code>autoGeneratedTimeStamp</code> is set</p>
<pre><code class="language-java">// generate id if not already provided and id generation is allowed
if (allowIdGeneration &amp;&amp; id == null) {
    assert autoGeneratedTimestamp == -1;
    autoGeneratedTimestamp = Math.max(0, System.currentTimeMillis()); // extra paranoia
    id(UUIDs.base64UUID());
}
</code></pre>
<p>The use for a  timestamp instead of using a string is related to version conflicts , which we don’t need to cover here, so we can see from 4th line that if we don’t pass the id on client side, then here it sets both the <code>autoGeneratedTimestamp</code> &amp; also updates the id.</p>
<p>So from all these, we can see that <code>InternalEngine.canOptimizeAddDocument</code> show above will return false, so in <code>InternalEngine.planIndexingAsPrimary</code> the else branch will be executed</p>
<pre><code class="language-java">    private IndexingStrategy planIndexingAsPrimary(Index index) throws IOException {
        assert index.origin() == Operation.Origin.PRIMARY :
            &quot;planing as primary but origin isn&#39;t. got &quot; + index.origin();
        final IndexingStrategy plan;
        // resolve an external operation into an internal one which is safe to replay
        if (canOptimizeAddDocument(index)) {
            . . .
        } else {
            // resolves incoming version
            final VersionValue versionValue = resolveDocVersion(index);
            final long currentVersion;
            final boolean currentNotFoundOrDeleted;
            if (versionValue == null) {
                currentVersion = Versions.NOT_FOUND;
                currentNotFoundOrDeleted = true;
            } else {
                currentVersion = versionValue.getVersion();
                currentNotFoundOrDeleted = versionValue.isDelete();
            }
            if (index.versionType().isVersionConflictForWrites(
                currentVersion, index.version(), currentNotFoundOrDeleted)) {
                plan = IndexingStrategy.skipDueToVersionConflict(
                    new VersionConflictEngineException(shardId, index, currentVersion,
                        currentNotFoundOrDeleted),
                    currentNotFoundOrDeleted, currentVersion);
            } else {
                plan = IndexingStrategy.processNormally(currentNotFoundOrDeleted,
                    index.versionType().updateVersion(currentVersion, index.version())
                );
            }
        }
        return plan;
    }
</code></pre>
<p>The else branch calls <code>resolveDocVersion</code> and then according to that a plan is decided. </p>
<pre><code class="language-java">/** resolves the current version of the document, returning null if not found */
private VersionValue resolveDocVersion(final Operation op) throws IOException {
    assert incrementVersionLookup(); // used for asserting in tests
    VersionValue versionValue = versionMap.getUnderLock(op.uid());
    if (versionValue == null) {
        assert incrementIndexVersionLookup(); // used for asserting in tests
        final long currentVersion = loadCurrentVersionFromIndex(op.uid());
        if (currentVersion != Versions.NOT_FOUND) {
            versionValue = new VersionValue(currentVersion);
        }
    } else if (engineConfig.isEnableGcDeletes() &amp;&amp; versionValue.isDelete() &amp;&amp;
        (engineConfig.getThreadPool().relativeTimeInMillis() - versionValue.getTime()) &gt;
            getGcDeletesInMillis()) {
        versionValue = null;
    }
    return versionValue;
}
</code></pre>
<p>The <code>resolveDocVersion</code> first checks the data in live maps that whether this id is used already or not, for new document it will return null</p>
<p>so next it calls  <code>loadCurrentVersionFromIndex(op.uid())</code> which indirectly calls <code>VersionResolvers.loadDocIdAndVersion</code> with <code>_id</code> set by the client</p>
<pre><code class="language-java">/**
 * Load the internal doc ID and version for the uid from the reader, returning&lt;ul&gt;
*&lt;li&gt;null if the uid wasn&#39;t found,
 *&lt;li&gt;a doc ID and a version otherwise
 *&lt;/ul&gt;
*/
public static DocIdAndVersion loadDocIdAndVersion(IndexReader reader, Term term)
    throws IOException {
    List&lt;LeafReaderContext&gt; leaves = reader.leaves();
    if (leaves.isEmpty()) {
        return null;
    }
    // iterate backwards to optimize for the frequently updated documents
    // which are likely to be in the last segments
    for (int i = leaves.size() - 1; i &gt;= 0; i--) {
        LeafReaderContext context = leaves.get(i);
        LeafReader leaf = context.reader();
        PerThreadIDAndVersionLookup lookup =getLookupState(leaf, term.field());
        DocIdAndVersion result =
            lookup.lookupVersion(term.bytes(), leaf.getLiveDocs(), context);
        if (result != null) {
            return result;
        }
    }
    return null;
}
</code></pre>
<p><code>loadDocIdAndVersion</code> searches through the whole index and then returns null if document is not found
This is the function which case become bottleneck or slowdown indexing when indices are big. As it needs to iterate though all the segments in the index.
One more problem with this is that, in a single shard Elasticsearch still doesn’t support concurrent searching on multiple segments  (See <a href="https://github.com/elastic/elasticsearch/issues/80693">https://github.com/elastic/elasticsearch/issues/80693</a>)</p>
<p>Finally the <code>indexIntoLucence</code> is called, which calls <code>index(index.docs(), indexWriter)</code> and thus the document get’s indexed into ES.</p>
<pre><code class="language-java">private IndexResult indexIntoLucene(Index index, IndexingStrategy plan)
    throws IOException {
    assert plan.versionForIndexing &gt;= 0 : &quot;version must be set. got &quot; + plan.versionForIndexing;
    assert plan.indexIntoLucene;
    index.parsedDoc().version().setLongValue(plan.versionForIndexing);
    try {
        if (plan.useLuceneUpdateDocument) {
            update(index.uid(), index.docs(), indexWriter);
        } else {
            // document does not exists, we can optimize for create, but double check if assertions are running
            assert assertDocDoesNotExist(index, canOptimizeAddDocument(index) == false);
            index(index.docs(), indexWriter);
        }
        versionMap.putUnderLock(index.uid().bytes(), new VersionValue(plan.versionForIndexing));
        return new IndexResult(plan.versionForIndexing, plan.currentNotFoundOrDeleted);
    } catch (Exception ex) {
       ...
    }
}
</code></pre>



<h2>Wrapping Up</h2>

<p>So in conclusion if we don’t provide the id manually , ES will auto generate it, and <code class="language-java">loadDocIdAndVersion</code> method will not be called, thus increasing indexing throughput.</p>
<p>I hope that this article has been helpful to you. If this is the kind
of thing that interests you, you may enjoy my <a href=articles.html>other
work</a>. If you have any questions, corrections, or comments please drop
me a line!

<address>
Arvind Mahto<br>
mh@mhtocs.com
</address>
